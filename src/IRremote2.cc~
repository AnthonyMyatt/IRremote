#include <node.h>
#include <v8.h>
#include <cvv8/convert.hpp>
#include <string>
#include <unistd.h>

#include <libpwm.h>

#include "IRremoteInt.h"

using namespace v8;
using namespace std;

class IRsend : public node::ObjectWrap {
public:
    static v8::Persistent<v8::FunctionTemplate> constructor;
    static void Init(v8::Handle<v8::Object> target);
    IRsend();

    // These functions are bound to Javascript
    static v8::Handle<v8::Value> sendNEC(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendSony(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendRaw(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendRC5(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendRC6(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendDISH(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendSharp(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendPanasonic(const v8::Arguments& args);
    static v8::Handle<v8::Value> sendJVC(const v8::Arguments& args);

protected:
    static v8::Handle<v8::Value> New(const v8::Arguments& args);

    static void sendNEC(uv_work_t* req);
    static void sendSony(uv_work_t* req);
    static void sendRaw(uv_work_t* req);
    static void sendRC5(uv_work_t* req);
    static void sendRC6(uv_work_t* req);
    static void sendDISH(uv_work_t* req);
    static void sendSharp(uv_work_t* req);
    static void sendPanasonic(uv_work_t* req);
    static void sendJVC(uv_work_t* req);

    static void doCallback(uv_work_t* req);

    // private
    void enableIROut(int khz);
    void mark(int usec, string pin);
    void space(int usec, string pin);

private:
    LibPWM pwm;
    std::string selectedPin;
    static uv_loop_t *loop;

    static const string SEND_PIN_1;
    static const string SEND_PIN_2;
    static const string SEND_PIN_3;
    static const string RECV_PIN;
};

// This defines the base structure passed to all uv_work threads
struct req_data
{
    IRsend* self;
    Persistent<Function> callback;
};

// These extend the base structure for each function
struct Generic_req : req_data	// NEC, Sony, RC5, RC6, DISH, Sharp
{
    unsigned long data;
    int nbits;
    string pin;
};

struct Raw_req : req_data
{
    unsigned int buf[];
    int len;
    int hz;
    string pin;
};

struct Panasonic_req : req_data
{
    unsigned int address;
    unsigned long data;
    string pin;
};

struct JVC_req : req_data
{
    unsigned long data;
    int nbits;
    int repeat;
    string pin;
};

// ---------------------------

const string IRsend::SEND_PIN_1 = "GPIO1_1";
const string IRsend::SEND_PIN_2 = "GPIO1_2";
const string IRsend::SEND_PIN_3 = "GPIO1_3";
const string IRsend::RECV_PIN   = "GPIO1_4";

uv_loop_t* IRsend::loop = uv_loop_new();

Persistent<FunctionTemplate> IRsend::constructor;

void IRsend::Init(Handle<Object> target) {
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("IRsend");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    // ObjectWrap uses the first internal field to store the wrapped pointer
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    // Register the constants
    target->Set(String::NewSymbol("SEND_PIN_1"), cvv8::CastToJS<const std::string> (SEND_PIN_1));
    target->Set(String::NewSymbol("SEND_PIN_2"), cvv8::CastToJS<const std::string> (SEND_PIN_2));
    target->Set(String::NewSymbol("SEND_PIN_3"), cvv8::CastToJS<const std::string> (SEND_PIN_3));
    target->Set(String::NewSymbol("RECV_PIN"), cvv8::CastToJS<const std::string> (RECV_PIN));

    // Register the functions
    NODE_SET_PROTOTYPE_METHOD(constructor, "sendNEC", sendNEC);

    target->Set(name, constructor->GetFunction());
}

IRsend::IRsend()
: ObjectWrap() {}

Handle<Value> IRsend::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(
                                                   String::New("Use the new operator to create instances of this object"))
                              );
    }

    IRsend* obj = new IRsend();

    obj->Wrap(args.This());

    return args.This();
}

// Private

void IRsend::mark(int time, string pin)
{
    // GPIO::digital_write(pin, 1);
    if (time > 0) usleep(time);
}

void IRsend::space(int time, string pin)
{
    // GPIO::digital_write(pin, 0);
    if (time > 0) usleep(time);
}

void IRsend::enableIROut(int khz)
{
    pwm.stop();
    pwm.setPeriod(khz*1000);
    pwm.setDuty(0.5);
    pwm.run();
}

// Public

Handle<Value> IRsend::sendNEC(const Arguments& args)
{
    HandleScope scope;

    if ( args.Length() < 3 )
    {
        return ThrowException(Exception::TypeError(String::New("Bad argument")));
    }

    IRsend* self = ObjectWrap::Unwrap<IRsend>(args.This());

    unsigned long data = cvv8::CastFromJS<unsigned long> (args[0]);
    int nbits = cvv8::CastFromJS<int> (args[1]);
    string pin = cvv8::CastFromJS<std::string> (args[2]);

    Generic_req* request = new Generic_req;
    request->self = self;
    request->data = data;
    request->nbits = nbits;
    request->pin = pin;

    if ( args.Length() > 3 && args[3]->IsFunction() )
    {
        Local<Function> callback = Local<Function>::Cast(args[3]);

	request->callback = Persistent<Function>::New(callback);
    }

    uv_work_t req;
    req.data = request;

    uv_queue_work(loop, &req, sendNEC, doCallback);

    return args.This();
}

void IRsend::sendNEC(uv_work_t* req)
{
    Generic_req* request = (Generic_req*)req->data;

    IRsend* self = request->self;
    unsigned long data = request->data;
    int nbits = request->nbits;
    string pin = request->pin;

    self->enableIROut(38);
    self->mark(NEC_HDR_MARK, pin);
    self->space(NEC_HDR_SPACE, pin);
    for (int i = 0; i < nbits; i++)
    {
        if (data & TOPBIT)
        {
            self->mark(NEC_BIT_MARK, pin);
            self->space(NEC_ONE_SPACE, pin);
        }
        else
        {
            self->mark(NEC_BIT_MARK, pin);
            self->space(NEC_ZERO_SPACE, pin);
        }
        data <<= 1;
    }
    self->mark(NEC_BIT_MARK, pin);
    self->space(0, pin); 
}

void IRsend::doCallback(uv_work_t* req)
{
    req_data* request = (req_data*)req->data;
    delete req;

    TryCatch try_catch;

    //int argc = 0;
    //v8::Handle<v8::Value> argv* = NULL;
    request->callback->Call(Context::GetCurrent()->Global(), 0, NULL);

    if (try_catch.HasCaught())
    {
        
    }

    request->callback.Dispose();

    delete request;
}

// Register the module
void RegisterModule(Handle<Object> target) {
    IRsend::Init(target);
}

NODE_MODULE(IRremote, RegisterModule);
